import{StatusEffectManager}from"./statusEffects.js";import{COMBAT_PHASES}from"./constants.js";import{logger}from"./logger.js";import{t}from"./i18n/index.js";import{BlockingEngine}from"./combat/BlockingEngine.js";import{DamageSystem}from"./combat/DamageSystem.js";import{CombatCombos}from"./combat/CombatCombos.js";import{CombatPredictor}from"./combat/CombatPredictor.js";import{CombatUnitManager}from"./combat/CombatUnitManager.js";import{RangedPhase}from"./combat/RangedPhase.js";import{AttackPhase}from"./combat/AttackPhase.js";export const COMBAT_PHASE=COMBAT_PHASES;export class Combat{constructor(hero,enemies){this.hero=hero;this.enemies=Array.isArray(enemies)?enemies:[enemies];this.enemy=this.enemies[0];this.phase=COMBAT_PHASES.NOT_IN_COMBAT;this.defeatedEnemies=[];this.blockedEnemies=new Set;this.totalDamage=0;this.woundsReceived=0;this.statusEffects=new StatusEffectManager;this.blockingEngine=new BlockingEngine;this.damageSystem=new DamageSystem;this.unitManager=new CombatUnitManager;this.rangedPhaseController=new RangedPhase(this);this.attackPhaseController=new AttackPhase(this);this.summonedEnemies=new Map}get unitAttackPoints(){return this.unitManager.unitAttackPoints}set unitAttackPoints(v){this.unitManager.unitAttackPoints=v}get unitBlockPoints(){return this.unitManager.unitBlockPoints}set unitBlockPoints(v){this.unitManager.unitBlockPoints=v}get unitRangedPoints(){return this.unitManager.unitRangedPoints}set unitRangedPoints(v){this.unitManager.unitRangedPoints=v}get unitSiegePoints(){return this.unitManager.unitSiegePoints}set unitSiegePoints(v){this.unitManager.unitSiegePoints=v}get activatedUnits(){return this.unitManager.activatedUnits}set activatedUnits(v){this.unitManager.activatedUnits=v}start(){logger.info(`Combat started against ${this.enemies.length} enemies`);this.damageSystem.reset();this.unitManager.reset();this.phase=COMBAT_PHASES.RANGED;return{phase:this.phase,enemies:this.enemies,message:t("combat.message",{count:this.enemies.length})+" "+t("ui.phases.ranged")+"."}}rangedPhase(){return this.rangedPhaseController.update(this.enemies)}rangedAttackEnemy(enemy,rangedValue,siegeValue,element="physical"){return this.rangedPhaseController.executeAttack(enemy,rangedValue,siegeValue,element)}endRangedPhase(){if(this.phase!==COMBAT_PHASES.RANGED){return{error:t("ui.phases.ranged")}}if(this.enemies.length===0){return this.endCombat()}this.handleSummoning();this.phase=COMBAT_PHASES.BLOCK;return{phase:this.phase,message:t("combat.blockStarted")}}handleSummoning(){this.rangedPhaseController.handleSummoning(this.enemies,this.defeatedEnemies)}blockPhase(){if(this.phase!==COMBAT_PHASES.BLOCK){return{error:t("ui.phases.block")}}this.totalDamage=0;this.enemies.forEach(enemy=>{if(!this.blockedEnemies.has(enemy.id)){this.totalDamage+=enemy.getEffectiveAttack()}});return{totalDamage:this.totalDamage,blockedEnemies:Array.from(this.blockedEnemies),message:t("combat.totalDamage",{amount:this.totalDamage})}}blockEnemy(enemy,blockInput,movementPoints=0){if(this.phase!==COMBAT_PHASES.BLOCK){console.log("DEBUG: blockEnemy Phase Warning. Current:",this.phase,"Expected:",COMBAT_PHASES.BLOCK);return{success:false,error:t("ui.phases.block")}}if(this.blockedEnemies.has(enemy.id)){return{success:false,message:t("combat.alreadyBlocked")}}const result=this.blockingEngine.calculateBlock(enemy,blockInput,this.unitBlockPoints,movementPoints);if(result.success&&result.blocked){this.blockedEnemies.add(enemy.id);if(result.unitPointsConsumed>0){this.unitBlockPoints=0}}return result}endBlockPhase(){if(this.phase!==COMBAT_PHASES.BLOCK){return{error:t("ui.phases.block")}}this.phase=COMBAT_PHASES.DAMAGE;return this.damagePhase()}damagePhase(){if(this.phase!==COMBAT_PHASES.DAMAGE){return{error:t("ui.phases.combat")}}this.unblockedEnemies=this.enemies.filter(e=>!this.blockedEnemies.has(e.id));if(this.unblockedEnemies.length===0){this.phase=COMBAT_PHASES.ATTACK;return{totalDamage:0,woundsReceived:0,unblockedEnemies:[],message:t("combat.damageSkipped"),nextPhase:COMBAT_PHASES.ATTACK}}this.totalDamage=this.unblockedEnemies.reduce((sum,e)=>sum+e.getEffectiveAttack(),0);return{totalDamage:this.totalDamage,unblockedEnemies:this.unblockedEnemies,message:t("combat.assignDamage"),nextPhase:COMBAT_PHASES.DAMAGE,waitingForAssignment:true}}resolveDamagePhase(){if(this.phase!==COMBAT_PHASES.DAMAGE)return;const activeUnblocked=this.unblockedEnemies.filter(e=>!e.damageAssigned);const result=this.damageSystem.calculateDamage(this.hero,activeUnblocked);this.totalDamage=result.totalDamage;this.woundsReceived=result.woundsReceived;this.paralyzeTriggered=result.paralyzeTriggered;this.phase=COMBAT_PHASES.ATTACK;return{totalDamage:this.totalDamage,woundsReceived:this.woundsReceived,paralyzeTriggered:this.paralyzeTriggered,message:result.message,nextPhase:COMBAT_PHASES.ATTACK}}assignDamageToUnit(unit,enemyId=null){if(this.phase!==COMBAT_PHASES.DAMAGE){return{success:false,message:t("combat.phaseDamageOnly")}}let enemy=null;if(enemyId){enemy=this.unblockedEnemies.find(e=>e.id===enemyId)}else{enemy=this.unblockedEnemies.find(e=>!e.damageAssigned&&!e.assassin)}if(!enemy){if(this.unblockedEnemies.some(e=>e.assassin&&!e.damageAssigned)){return{success:false,message:t("combat.assassinateRestriction",{enemy:"Assassin"})}}return{success:false,message:t("combat.noEnemyToAssign")}}if(enemy.damageAssigned){return{success:false,message:t("combat.alreadyAssigned")}}if(unit.wounds>0&&!unit.isResistantTo(enemy.attackType)){}const result=this.damageSystem.assignDamageToUnit(unit,enemy);if(result.success){enemy.damageAssigned=true;this.totalDamage-=enemy.getEffectiveAttack();return{success:true,message:t("combat.damageAssignedTo",{unit:unit.getName(),enemy:enemy.name}),unitDestroyed:result.unitDestroyed}}else{return result}}handleParalyzeEffect(){if(!this.paralyzeTriggered)return 0;const discarded=this.hero.discardNonWoundCards(this.woundsReceived);this.paralyzeTriggered=false;return discarded}attackPhase(){return this.attackPhaseController.update(this.enemies)}activateUnit(unit){return this.unitManager.activateUnit(unit,this.phase)}attackEnemies(attackValue,attackElement="physical",targetEnemies=null){return this.attackPhaseController.executeAttack(attackValue,attackElement,targetEnemies)}detectCombo(playedCards){return CombatCombos.detectCombo(playedCards)}calculateCriticalHit(baseAttack,critChance=.15){return CombatCombos.calculateCriticalHit(baseAttack,critChance)}applyComboBonus(baseValue,combo){return CombatCombos.applyComboBonus(baseValue,combo)}applyEffectToHero(effectType,source=null){return this.statusEffects.applyToHero(this.hero,effectType,source)}applyEffectToEnemy(enemy,effectType,source=null){return this.statusEffects.applyToEnemy(enemy,effectType,source)}getHeroEffects(){return this.statusEffects.getHeroEffects()}getEnemyEffects(enemy){return this.statusEffects.getEnemyEffects(enemy)}processPhaseEffects(){const results={heroDamage:0,enemyDamage:[],messages:[]};const heroResult=this.statusEffects.processHeroPhaseStart(this.hero);if(heroResult&&heroResult.damage){results.heroDamage=heroResult.damage;results.messages.push(t("combat.heroStatusDamage",{amount:heroResult.damage}))}const enemyResults=this.statusEffects.processEnemyPhaseStart(this.enemies);for(const result of enemyResults){if(result.damage){results.enemyDamage.push({enemy:result.enemy,damage:result.damage});results.messages.push(t("combat.enemyStatusDamage",{enemy:result.enemy.name,amount:result.damage}))}}return results}endCombat(){const endResult=this.statusEffects.processCombatEnd(this.hero);if(endResult.wounds>0){for(let i=0;i<endResult.wounds;i++){this.hero.takeWound()}this.woundsReceived+=endResult.wounds}this.statusEffects.clear();this.phase=COMBAT_PHASES.COMPLETE;const allDefeated=this.enemies.length===0;const result={victory:allDefeated,defeatedEnemies:this.defeatedEnemies,remainingEnemies:this.enemies,woundsReceived:this.woundsReceived,fameGained:this.defeatedEnemies.reduce((sum,e)=>sum+e.fame,0),poisonWounds:endResult.wounds,message:allDefeated?t("game.victory"):t("combat.combatEnded")};return result}getPredictedOutcome(currentAttack=0,currentBlock=0){return CombatPredictor.getPredictedOutcome(this,currentAttack,currentBlock)}isComplete(){return this.phase===COMBAT_PHASES.COMPLETE}getState(){return{phase:this.phase,enemies:this.enemies.map(e=>e.getState()),defeatedEnemies:this.defeatedEnemies,blockedEnemies:Array.from(this.blockedEnemies),totalDamage:this.totalDamage,woundsReceived:this.woundsReceived,...this.unitManager.getState()}}loadState(state){if(!state)return;this.phase=state.phase;this.enemies=state.enemies.map(eState=>{const existing=this.enemies.find(e=>e.id===eState.id);if(existing){existing.loadState(eState);return existing}return eState});this.defeatedEnemies=state.defeatedEnemies;this.blockedEnemies=new Set(state.blockedEnemies);this.totalDamage=state.totalDamage;this.woundsReceived=state.woundsReceived;this.unitManager.loadState(state)}}export default Combat;