import{ENEMY_TYPES,BOSS_PHASES,ENEMY_DEFINITIONS,BOSS_DEFINITIONS}from"./constants.js";import{t}from"./i18n/index.js";export{ENEMY_TYPES,BOSS_PHASES,ENEMY_DEFINITIONS,BOSS_DEFINITIONS};export class Enemy{constructor(data){this.id=data.id||`enemy_${Date.now()}`;this.type=data.type;this.name=data.name||(data.type?t(`enemies.${data.type}`):"Enemy");this.position=data.position||null;this.armor=data.armor||0;this.attack=data.attack||0;this.fame=data.fame||0;this.fortified=data.fortified||false;this.swift=data.swift||false;this.brutal=data.brutal||false;this.poison=data.poison||false;this.petrify=data.petrify||false;this.elusive=data.elusive||false;this.vampiric=data.vampiric||false;this.assassin=data.assassin||false;this.cumbersome=data.cumbersome||false;this.summoner=data.summoner||false;this.summoned=data.summoned||false;this.lowerArmor=data.lowerArmor||Math.floor((data.armor||1)/2);this.armorBonus=0;this.fireResist=data.fireResist||false;this.iceResist=data.iceResist||false;this.physicalResist=data.physicalResist||false;this.icon=data.icon||"ðŸ‘¹";this.color=data.color||"#ef4444";this.attackType=data.attackType||"physical"}getResistanceMultiplier(attackElement){if(attackElement==="fire"&&(this.fireResist||this.iceResist)){if(this.fireResist)return.5}if(attackElement==="fire"&&this.fireResist)return.5;if(attackElement==="ice"&&this.iceResist)return.5;if(attackElement==="physical"&&this.physicalResist)return.5;return 1}getCurrentArmor(isBlocked=false,isAttackPhase=false){let base=this.armor;if(this.elusive&&isAttackPhase&&isBlocked){base=this.lowerArmor}return base+this.armorBonus}getEffectiveAttack(){return this.brutal?this.attack*2:this.attack}getBlockRequirement(){let req=this.attack;if(this.swift)req*=2;return req}isDefeated(attackValue,isBlocked=false,isAttackPhase=false){if(attackValue!==undefined){return attackValue>=this.getCurrentArmor(isBlocked,isAttackPhase)}return false}getState(){return{id:this.id,type:this.type,name:this.name,position:this.position?{...this.position}:null,armor:this.armor,attack:this.attack,fame:this.fame,icon:this.icon,color:this.color,isBoss:this.isBoss||false}}loadState(state){if(!state)return;this.position=state.position?{...state.position}:null}clone(){return new Enemy({type:this.type,name:this.name,armor:this.armor,attack:this.attack,fame:this.fame,fortified:this.fortified,swift:this.swift,brutal:this.brutal,poison:this.poison,petrify:this.petrify,fireResist:this.fireResist,iceResist:this.iceResist,physicalResist:this.physicalResist,icon:this.icon,color:this.color})}}export class BossEnemy extends Enemy{constructor(data){super(data);this.isBoss=true;this.maxHealth=data.maxHealth||30;this.currentHealth=data.currentHealth||this.maxHealth;this.phases=data.phases||[{threshold:.66,name:t("ui.phases.phase1")||"Phase 1",triggered:false},{threshold:.33,name:t("ui.phases.phase2")||"Phase 2",triggered:false},{threshold:0,name:t("ui.phases.enraged")||"Enraged",triggered:false}];this.currentPhase=BOSS_PHASES.PHASE_1;this.enraged=false;this.enrageThreshold=data.enrageThreshold||.25;this.enrageMultiplier=data.enrageMultiplier||1.5;this.phaseAbilities=data.phaseAbilities||{[BOSS_PHASES.PHASE_1]:null,[BOSS_PHASES.PHASE_2]:"summon",[BOSS_PHASES.PHASE_3]:"heal",[BOSS_PHASES.ENRAGED]:"double_attack"};this.summonType=data.summonType||"weakling";this.summonCount=data.summonCount||2}takeDamage(amount){const previousHealth=this.currentHealth;this.currentHealth=Math.max(0,this.currentHealth-amount);const healthPercent=this.currentHealth/this.maxHealth;const transitions=[];for(const phase of this.phases){if(!phase.triggered&&healthPercent<=phase.threshold){phase.triggered=true;transitions.push({phase:phase.name,ability:this.getPhaseAbility(phase.name)})}}if(!this.enraged&&healthPercent<=this.enrageThreshold){this.enraged=true;this.currentPhase=BOSS_PHASES.ENRAGED;transitions.push({phase:t("ui.phases.enraged")||"Enraged",ability:"enrage",message:t("combat.boss.enraged",{name:this.name})})}return{damage:amount,previousHealth:previousHealth,currentHealth:this.currentHealth,healthPercent:healthPercent,transitions:transitions,defeated:this.currentHealth<=0}}getPhaseAbility(phaseName){if(this.phaseAbilities[phaseName]){return this.phaseAbilities[phaseName]}if(phaseName==="Phase 2")return this.phaseAbilities[BOSS_PHASES.PHASE_2];if(phaseName==="Phase 3")return this.phaseAbilities[BOSS_PHASES.PHASE_3];if(phaseName==="Enraged")return this.phaseAbilities[BOSS_PHASES.ENRAGED];return null}getEffectiveAttack(){let attack=super.getEffectiveAttack();if(this.enraged){attack=Math.floor(attack*this.enrageMultiplier)}return attack}isDefeated(_attackValue=null){return this.currentHealth<=0}getState(){const state=super.getState();return{...state,maxHealth:this.maxHealth,currentHealth:this.currentHealth,phase:this.phase,summonType:this.summonType,summonCount:this.summonCount}}loadState(state){super.loadState(state);if(state.currentHealth!==undefined)this.currentHealth=state.currentHealth;if(state.phase!==undefined)this.phase=state.phase}getHealthPercent(){return this.currentHealth/this.maxHealth}getPhaseName(){if(this.enraged)return t("ui.phases.enraged")||"WÃ¼tend";const healthPercent=this.getHealthPercent();if(healthPercent>.66)return t("ui.phases.phase1")||"Phase 1";if(healthPercent>.33)return t("ui.phases.phase2")||"Phase 2";return t("ui.phases.phase3")||"Phase 3"}executePhaseAbility(abilityName){switch(abilityName){case"summon":return{type:"summon",enemyType:this.summonType,count:this.summonCount,message:t("combat.boss.summons",{name:this.name,count:this.summonCount,enemy:t(`enemies.${this.summonType}`)})};case"heal":{const healAmount=Math.floor(this.maxHealth*.1);this.currentHealth=Math.min(this.maxHealth,this.currentHealth+healAmount);return{type:"heal",amount:healAmount,message:t("combat.boss.heals",{name:this.name,amount:healAmount})}}case"enrage":case"double_attack":return{type:"buff",message:t("combat.boss.doubleAttack",{name:this.name})};default:return null}}}export function createEnemy(enemyKey,position=null){const def=ENEMY_DEFINITIONS[enemyKey];if(!def){console.error(`Unknown enemy type: ${enemyKey}`);return null}return new Enemy({...def,name:t(`enemies.${enemyKey}`)!==`enemies.${enemyKey}`?t(`enemies.${enemyKey}`):def.name,type:enemyKey,position:position})}export function createEnemies(enemyList){return enemyList.map(({type:type,position:position})=>createEnemy(type,position))}export function createBoss(bossKey,position=null){const def=BOSS_DEFINITIONS[bossKey];if(!def){console.error(`Unknown boss type: ${bossKey}`);return null}return new BossEnemy({...def,name:t(`enemies.${bossKey}`)!==`enemies.${bossKey}`?t(`enemies.${bossKey}`):def.name,type:bossKey,position:position})}export default Enemy;