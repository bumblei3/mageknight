import{ENEMY_TYPES,createEnemy,createBoss}from"./enemy.js";export const ENEMY_ABILITIES={NONE:"none",POISON:"poison",FREEZE:"freeze",FIRE:"fire",SUMMON:"summon",HEAL:"heal",VAMPIRIC:"vampiric"};export class EnemyAI{constructor(game){this.game=game;this.difficulty=1}generateEnemy(terrainType,level=1){const difficulty=Math.min(10,Math.ceil(level/2)+this.difficulty);let type=ENEMY_TYPES.ORC;if(terrainType==="mountain"||terrainType==="wasteland"){if(difficulty>7)type=ENEMY_TYPES.DRACONUM;else if(difficulty>5)type=ENEMY_TYPES.ELEMENTAL;else type=ENEMY_TYPES.ORC}else if(terrainType==="swamp"||terrainType==="ruins"){if(difficulty>6)type=ENEMY_TYPES.NECROMANCER;else if(difficulty>4)type=ENEMY_TYPES.MAGE_TOWER;else type=ENEMY_TYPES.ORC}else if(terrainType==="forest"){if(difficulty>3)type=ENEMY_TYPES.ROBBER}const enemy=createEnemy(type);if(!enemy)return createEnemy(ENEMY_TYPES.ORC);const scalingFactor=Math.max(0,difficulty-3);if(scalingFactor>0){enemy.armor+=Math.floor(scalingFactor/2);enemy.attack+=Math.floor(scalingFactor/2);enemy.fame+=scalingFactor;if(difficulty>5&&!enemy.abilities)enemy.abilities=[];if(difficulty>5&&Math.random()>.5)enemy.abilities.push(ENEMY_ABILITIES.POISON);if(difficulty>8)enemy.abilities.push(ENEMY_ABILITIES.VAMPIRIC)}enemy.level=difficulty;enemy.maxHealth=enemy.armor;enemy.currentHealth=enemy.armor;enemy.abilities=enemy.abilities||[];if(enemy.poison)enemy.abilities.push(ENEMY_ABILITIES.POISON);return enemy}decideAction(enemy,_heroState){return{type:"attack",value:enemy.attack,abilities:enemy.abilities}}applyAbility(ability,target,source){switch(ability){case ENEMY_ABILITIES.POISON:return{effect:"wound",count:1,message:"Vergiftet! +1 Verletzung"};case ENEMY_ABILITIES.FIRE:return{effect:"damage_boost",message:"Feuerangriff! Doppelter Schaden"};case ENEMY_ABILITIES.VAMPIRIC:{const heal=1;source.currentHealth=Math.min(source.maxHealth,source.currentHealth+heal);return{effect:"heal",value:heal,message:"Lebensraub! Feind heilt sich"}}default:return null}}updateEnemies(enemies,hero){const moveLog=[];enemies.forEach(enemy=>{if(enemy.isDefeated)return;if(enemy.currentHealth<enemy.maxHealth){enemy.currentHealth=Math.min(enemy.maxHealth,enemy.currentHealth+1)}if(this.canMove(enemy)){const move=this.getBestMove(enemy,hero.position,enemies);if(move){enemy.position=move;moveLog.push(`${enemy.name} bewegt sich.`)}}});return moveLog}canMove(enemy){const roamingTypes=[ENEMY_TYPES.ORC,ENEMY_TYPES.DRACONUM,ENEMY_TYPES.ELEMENTAL,ENEMY_TYPES.ROBBER];return roamingTypes.includes(enemy.type)}getBestMove(enemy,heroPos,allEnemies){if(!enemy.position)return null;const currentQ=enemy.position.q;const currentR=enemy.position.r;const neighbors=this.game.hexGrid.getNeighbors(currentQ,currentR);const validMoves=neighbors.filter(n=>{if(!this.game.hexGrid.hasHex(n.q,n.r))return false;const hex=this.game.hexGrid.getHex(n.q,n.r);if(!hex||hex.terrain==="water"||hex.terrain==="mountains")return false;const isOccupied=allEnemies.some(e=>e!==enemy&&!e.isDefeated&&e.position&&e.position.q===n.q&&e.position.r===n.r);if(isOccupied)return false;if(heroPos.q===n.q&&heroPos.r===n.r)return false;return true});if(validMoves.length===0)return null;const distToHero=this.game.hexGrid.distance(currentQ,currentR,heroPos.q,heroPos.r);const isAggro=distToHero<=3;if(isAggro){validMoves.sort((a,b)=>{const da=this.game.hexGrid.distance(a.q,a.r,heroPos.q,heroPos.r);const db=this.game.hexGrid.distance(b.q,b.r,heroPos.q,heroPos.r);return da-db});return validMoves[0]}else{if(Math.random()<.2)return null;return validMoves[Math.floor(Math.random()*validMoves.length)]}}reconstituteEnemy(eData){let enemy;if(eData.isBoss){enemy=createBoss(eData.type,eData.position)}else{enemy=createEnemy(eData.type,eData.position)}if(enemy&&enemy.loadState){enemy.loadState(eData)}return enemy}}