import{Combat}from"../combat.js";import{eventBus}from"../eventBus.js";import{GAME_EVENTS,COMBAT_PHASES}from"../constants.js";import{t}from"../i18n/index.js";import Enemy,{ENEMY_DEFINITIONS}from"../enemy.js";export class CombatOrchestrator{constructor(game){this.game=game;this.combatAttackTotal=0;this.combatBlockTotal=0;this.activeBlocks=[];this.combatRangedTotal=0;this.combatSiegeTotal=0}playCardInCombat(index,card,useStrong=false){if(!this.game.combat||card.isWound())return;if(this.game.actionManager){this.game.actionManager.saveCheckpoint()}const result=this.game.hero.playCard(index,useStrong,this.game.timeManager.isNight());if(!result)return;const rect=this.game.ui.elements.playedCards.getBoundingClientRect();this.game.particleSystem.playCardEffect(rect.right-50,rect.top+75,result.card.color);const phase=this.game.combat.phase;if(phase===COMBAT_PHASES.BLOCK&&result.effect.block){this.combatBlockTotal+=result.effect.block;this.activeBlocks.push({value:result.effect.block,element:result.effect.element||"physical"})}else if(phase===COMBAT_PHASES.RANGED){if(result.effect.siege){this.combatSiegeTotal+=result.effect.attack||0}else if(result.card.type==="spell"||result.effect.ranged){this.combatRangedTotal+=result.effect.attack||0}}else if(phase===COMBAT_PHASES.ATTACK&&result.effect.attack){this.combatAttackTotal+=result.effect.attack}this.game.addLog(t("combat.cardPlayed",{card:result.card.name}),"combat");this.game.ui.addPlayedCard(result.card,result.effect);this.game.ui.showPlayArea();this.game.renderHand();this.game.updateStats();this.updateCombatTotals()}renderUnitsInCombat(){if(!this.game.combat)return;const units=this.game.hero.units;this.game.ui.renderUnitsInCombat(units,this.game.combat.phase,u=>this.activateUnitInCombat(u))}activateUnitInCombat(unit){if(!this.game.combat)return;const result=this.game.combat.activateUnit(unit);if(result.success){this.game.addLog(result.message,"combat");const heroPixel=this.game.hexGrid.axialToPixel(this.game.hero.position.q,this.game.hero.position.r);this.game.particleSystem.buffEffect(heroPixel.x,heroPixel.y);this.renderUnitsInCombat();this.game.updateStats()}else{this.game.addLog(result.message,"info")}}endBlockPhase(){if(!this.game.combat)return;this.game.combat.blockEnemy(this.game.combat.enemy,this.combatBlockTotal);if(this.game.actionManager)this.game.actionManager.clearHistory();const result=this.game.combat.endBlockPhase();if(result.waitingForAssignment){this.game.addLog(result.message,"info");this.combatBlockTotal=0;this.activeBlocks=[];this.game.updatePhaseIndicator();this.updateCombatInfo();this.renderUnitsInCombat();return}this.handleDamageResults(result);this.combatBlockTotal=0;this.activeBlocks=[];this.renderUnitsInCombat();this.game.updatePhaseIndicator();this.game.updateStats();this.updateCombatTotals()}assignDamageToUnit(unit){if(!this.game.combat)return;const result=this.game.combat.assignDamageToUnit(unit);if(result.success){this.game.addLog(result.message,"warning");if(result.unitDestroyed){this.game.particleSystem.triggerShake(5,.5)}this.updateCombatInfo();this.renderUnitsInCombat();this.game.updateStats()}else{this.game.addLog(result.message,"error")}}resolveDamagePhase(){if(!this.game.combat)return;const result=this.game.combat.resolveDamagePhase();if(result){this.handleDamageResults(result);this.updateCombatInfo();this.game.updateStats();this.game.updatePhaseIndicator();this.renderUnitsInCombat()}}handleDamageResults(result){if(result.woundsReceived>0){const heroPixel=this.game.hexGrid.axialToPixel(this.game.hero.position.q,this.game.hero.position.r);this.game.particleSystem.damageSplatter(heroPixel.x,heroPixel.y,result.woundsReceived);this.game.particleSystem.triggerShake(result.woundsReceived*2,.4);this.game.particleSystem.createDamageNumber(heroPixel.x,heroPixel.y,result.woundsReceived,true)}if(result.paralyzeTriggered){const discarded=this.game.combat.handleParalyzeEffect();if(discarded>0){this.game.addLog(t("combat.paralyzeDiscard",{count:discarded}),"warning");const heroPixel=this.game.hexGrid.axialToPixel(this.game.hero.position.q,this.game.hero.position.r);this.game.particleSystem.createFloatingText(heroPixel.x,heroPixel.y,`-${discarded} Karten (Versteinert)`,"#ef4444")}}this.game.addLog(result.message,"combat")}executeAttackAction(){if(!this.game.combat)return;if(this.game.combat.phase===COMBAT_PHASES.RANGED){this.endRangedPhase();return}if(this.game.combat.phase===COMBAT_PHASES.BLOCK){this.endBlockPhase();return}if(this.game.combat.phase===COMBAT_PHASES.DAMAGE){this.resolveDamagePhase();return}if(this.game.combat.phase!==COMBAT_PHASES.ATTACK)return;if(this.game.actionManager)this.game.actionManager.clearHistory();const pixelPos=this.game.hexGrid.axialToPixel(this.game.combat.enemy.position.q,this.game.combat.enemy.position.r);this.game.particleSystem.combatClashEffect(pixelPos.x,pixelPos.y,"physical");const attackResult=this.game.combat.attackEnemies(this.combatAttackTotal,"physical");if(this.combatAttackTotal>0){this.game.particleSystem.createDamageNumber(pixelPos.x,pixelPos.y,this.combatAttackTotal);if(this.combatAttackTotal>=4){this.game.particleSystem.triggerShake(3,.3)}}this.game.addLog(attackResult.message,attackResult.success?"success":"warning");if(attackResult.success){this.onCombatEnd({victory:true,enemy:this.game.combat.enemy})}else{this.updateCombatInfo()}}endRangedPhase(){if(!this.game.combat)return;const result=this.game.combat.endRangedPhase();this.game.addLog(result.message,"combat");if(result.phase===COMBAT_PHASES.BLOCK){this.renderUnitsInCombat();this.game.updatePhaseIndicator();this.game.updateStats();this.updateCombatTotals()}else if(result.victory){this.onCombatEnd({victory:true,enemy:this.game.combat.enemy})}}initiateCombat(enemyOrEnemies){if(this.game.gameState!=="playing"||this.game.combat)return;let enemies=Array.isArray(enemyOrEnemies)?enemyOrEnemies:[enemyOrEnemies];const processedEnemies=enemies.map(enemy=>{if(enemy.summoner){let summonKey="orc";const candidates=Object.keys(ENEMY_DEFINITIONS).filter(k=>{const def=ENEMY_DEFINITIONS[k];return!def.summoner&&!def.fortified&&k!=="weakling"});if(candidates.length>0){summonKey=candidates[Math.floor(Math.random()*candidates.length)]}const summonDef=ENEMY_DEFINITIONS[summonKey]||ENEMY_DEFINITIONS["orc"];const summonedEnemy=new Enemy({...summonDef,id:`summoned_${Date.now()}_${Math.random().toString(36).substr(2,9)}`});this.game.addLog(t("combat.summoning",{summoner:enemy.name,summoned:summonedEnemy.name}),"warning");return summonedEnemy}return enemy});enemies=processedEnemies;const names=enemies.map(e=>e.name).join(" & ");this.game.addLog(t("combat.fightAgainst",{enemy:names}),"combat");this.game.combat=new Combat(this.game.hero,enemies,result=>this.onCombatEnd(result));this.game.combat.start();this.game.gameState="combat";this.combatAttackTotal=0;this.combatBlockTotal=0;this.game.ui.showCombatPanel(enemies,this.game.combat.phase,e=>this.handleEnemyClick(e));this.game.updatePhaseIndicator();eventBus.emit(GAME_EVENTS.COMBAT_STARTED,{enemies:enemies})}handleEnemyClick(enemy){if(!this.game.combat)return;if(this.game.combat.phase===COMBAT_PHASES.RANGED){this.executeRangedAttack(enemy)}else if(this.game.combat.phase===COMBAT_PHASES.BLOCK){const movementPoints=this.game.hero.movementPoints;let movementToSpend=movementPoints;if(enemy.cumbersome&&movementPoints>0){}const result=this.game.combat.blockEnemy(enemy,this.activeBlocks,movementToSpend);if(result.success&&result.blocked){if(enemy.cumbersome&&movementPoints>0){const rawReq=typeof enemy.getBlockRequirement==="function"?enemy.getBlockRequirement():enemy.attack;const effectiveFromCardsAndUnits=result.totalBlock;const neededMove=Math.max(0,rawReq-effectiveFromCardsAndUnits);const actualSpent=Math.min(movementPoints,neededMove);if(actualSpent>0){this.game.hero.movementPoints=Math.max(0,this.game.hero.movementPoints-actualSpent);this.game.addLog(t("combat.cumbersomeUsed",{enemy:enemy.name,amount:actualSpent}),"info")}}const pixelPos=this.game.hexGrid.axialToPixel(enemy.position.q,enemy.position.r);this.game.particleSystem.shieldBlockEffect(pixelPos.x,pixelPos.y)}this.activeBlocks=[];this.combatBlockTotal=0;this.updateCombatInfo();this.game.updateStats()}}updateCombatInfo(){if(!this.game.combat)return;this.game.ui.updateCombatInfo(this.game.combat.enemies,this.game.combat.phase,e=>this.handleEnemyClick(e));this.updateCombatTotals()}updateCombatTotals(){if(!this.game.combat)return;this.game.ui.updateCombatTotals(this.combatAttackTotal,this.combatBlockTotal,this.game.combat.phase)}onCombatEnd(result){this.game.gameState="playing";const enemy=result.enemy||(this.game.combat?this.game.combat.enemies[0]:null);this.game.combat=null;this.combatAttackTotal=0;this.combatBlockTotal=0;this.activeBlocks=[];this.combatRangedTotal=0;this.combatSiegeTotal=0;if(result.victory&&enemy){this.game.addLog(t("combat.victoryOver",{enemy:enemy.name}),"success");this.game.entityManager.removeEnemy(enemy);const fameGained=enemy.fame||0;const levelResult=this.game.hero.gainFame(fameGained);this.game.statisticsManager.increment("enemiesDefeated");this.game.addLog(t("combat.fameReward",{amount:fameGained}),"info");if(levelResult&&levelResult.leveledUp){this.game.levelUpManager.handleLevelUp(levelResult)}const currentSite=this.game.siteManager.currentSite;if(currentSite&&!currentSite.conquered){if(currentSite.type==="dungeon"||currentSite.type==="ruin"){currentSite.conquered=true;const logKey=currentSite.type==="dungeon"?"combat.dungeonCleared":"combat.ruinCleared";this.game.addLog(t(logKey),"success");if(this.game.rewardManager){this.game.rewardManager.showArtifactChoice()}}else if(currentSite.type==="tomb"){currentSite.conquered=true;this.game.addLog(t("combat.tombCleared"),"success");if(this.game.rewardManager){this.game.rewardManager.showSpellChoice()}}else if(currentSite.type==="labyrinth"){currentSite.conquered=true;this.game.addLog(t("combat.labyrinthCleared"),"success");if(this.game.rewardManager){this.game.rewardManager.showArtifactChoice()}}else if(currentSite.type==="spawning_grounds"){currentSite.conquered=true;this.game.addLog(t("combat.spawningCleared"),"success");const healed=this.game.hero.healWound(false);if(healed){this.game.addLog("Die reinigende Energie heilt eine Wunde!","success");this.game.particleSystem.buffEffect(this.game.hexGrid.axialToPixel(this.game.hero.position.q,this.game.hero.position.r).x,this.game.hexGrid.axialToPixel(this.game.hero.position.q,this.game.hero.position.r).y,"green")}}else if(currentSite.type==="keep"||currentSite.type==="mage_tower"||currentSite.type==="mine"){currentSite.conquered=true;this.game.addLog(t("combat.siteConquered",{site:currentSite.getName()}),"success");this.game.statisticsManager.increment("sitesConquered");if(this.game.scenarioManager){const win=this.game.scenarioManager.checkVictory();if(win&&win.victory){setTimeout(()=>{this.game.showNotification("ðŸŽ‰ "+win.message,"success",1e4);this.game.addLog(win.message,"success")},1e3)}}}}}else if(result.defeat&&enemy){this.game.addLog(t("combat.defeatAgainst",{enemy:enemy.name}),"error")}else if(enemy){this.game.addLog(t("combat.retreatFrom",{enemy:enemy.name}),"info")}this.game.ui.hideCombatPanel();this.game.updateStats();this.game.updatePhaseIndicator();this.game.render();this.game.checkAndShowAchievements();eventBus.emit(GAME_EVENTS.COMBAT_ENDED,{victory:result.victory,enemy:enemy})}executeRangedAttack(enemy){if(!this.game.combat)return;const attackResult=this.game.combat.rangedAttackEnemy(enemy,this.combatRangedTotal||0,(this.combatSiegeTotal||0)+(this.game.hero.hasSkill("siege_mastery")?2:0));const damageDealt=(this.combatRangedTotal||0)+(this.combatSiegeTotal||0);if(enemy.position){const pixelPos=this.game.hexGrid.axialToPixel(enemy.position.q,enemy.position.r);this.game.particleSystem.impactEffect(pixelPos.x,pixelPos.y,"blue");if(damageDealt>0){this.game.particleSystem.createDamageNumber(pixelPos.x,pixelPos.y,damageDealt)}}else if(this.game.hero.position){const heroPixel=this.game.hexGrid.axialToPixel(this.game.hero.position.q,this.game.hero.position.r);this.game.particleSystem.impactEffect(heroPixel.x,heroPixel.y-50,"blue");if(damageDealt>0){this.game.particleSystem.createDamageNumber(heroPixel.x,heroPixel.y-50,damageDealt)}}this.game.addLog(attackResult.message,"combat");if(attackResult.success){this.combatRangedTotal=Math.max(0,this.combatRangedTotal-(attackResult.consumedRanged||0));this.combatSiegeTotal=Math.max(0,this.combatSiegeTotal-(attackResult.consumedSiege||0));if(this.game.combat.enemies.length===0){this.onCombatEnd({victory:true,enemy:enemy})}else{this.updateCombatInfo()}}else{this.updateCombatInfo()}}}