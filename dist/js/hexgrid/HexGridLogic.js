export class HexGridLogic{constructor(hexSize=40){this.hexSize=hexSize;this.hexes=new Map;this.terrainSystem=null}setTerrainSystem(terrainSystem){this.terrainSystem=terrainSystem}axialToPixelOffset(q,r){const x=this.hexSize*(3/2*q);const y=this.hexSize*(Math.sqrt(3)/2*q+Math.sqrt(3)*r);return{x:x,y:y}}pixelOffsetToAxial(x,y){const q=2/3*x/this.hexSize;const r=(-1/3*x+Math.sqrt(3)/3*y)/this.hexSize;return this.roundAxial(q,r)}roundAxial(q,r){const s=-q-r;let rq=Math.round(q);let rr=Math.round(r);let rs=Math.round(s);const q_diff=Math.abs(rq-q);const r_diff=Math.abs(rr-r);const s_diff=Math.abs(rs-s);if(q_diff>r_diff&&q_diff>s_diff){rq=-rr-rs}else if(r_diff>s_diff){rr=-rq-rs}return{q:rq,r:rr}}getHexKey(q,r){return`${q},${r}`}getNeighbors(q,r){const directions=[{q:1,r:0},{q:1,r:-1},{q:0,r:-1},{q:-1,r:0},{q:-1,r:1},{q:0,r:1}];return directions.map(dir=>({q:q+dir.q,r:r+dir.r}))}distance(q1,r1,q2,r2){return(Math.abs(q1-q2)+Math.abs(q1+r1-q2-r2)+Math.abs(r1-r2))/2}getHexesInRange(q,r,range){const results=[];for(let dq=-range;dq<=range;dq++){for(let dr=Math.max(-range,-dq-range);dr<=Math.min(range,-dq+range);dr++){results.push({q:q+dq,r:r+dr})}}return results}setHex(q,r,data){const key=this.getHexKey(q,r);const existing=this.hexes.get(key)||{};this.hexes.set(key,{...existing,...data,q:q,r:r})}getHex(q,r){return this.hexes.get(this.getHexKey(q,r))||null}hasHex(q,r){return this.hexes.has(this.getHexKey(q,r))}getMovementCost(q,r,isNight=false,hasFlight=false){if(hasFlight)return 1;const hex=this.getHex(q,r);if(!hex)return 999;if(this.terrainSystem){return this.terrainSystem.getMovementCost(hex.terrain,isNight)}const costs={plains:2,forest:3,hills:3,mountains:5,desert:5,wasteland:3,water:999};const cost=costs[hex.terrain]||2;if(isNight){if(hex.terrain==="forest")return 5;if(hex.terrain==="desert")return 3}return cost}getReachableHexes(startPos,movementPoints,isDay,hasFlight=false){if(!startPos)return[];const reachable=[];const queue=[{q:startPos.q,r:startPos.r,cost:0}];const visited=new Map;visited.set(this.getHexKey(startPos.q,startPos.r),0);while(queue.length>0){const current=queue.shift();if(current.q!==startPos.q||current.r!==startPos.r){reachable.push({q:current.q,r:current.r})}for(const neighbor of this.getNeighbors(current.q,current.r)){if(!this.hasHex(neighbor.q,neighbor.r))continue;const moveCost=this.getMovementCost(neighbor.q,neighbor.r,!isDay,hasFlight);const totalCost=current.cost+moveCost;if(totalCost<=movementPoints){const key=this.getHexKey(neighbor.q,neighbor.r);if(!visited.has(key)||visited.get(key)>totalCost){visited.set(key,totalCost);queue.push({...neighbor,cost:totalCost})}}}}return reachable}getState(){return{hexes:Array.from(this.hexes.entries())}}loadState(state){if(!state)return;if(state.hexes){this.hexes=new Map(state.hexes)}}}